OperatingSystems-Fall2023-Project1
**************README**************

Όνομα: Θεόδωρος Μωραΐτης
UserID: sdi2000150 (1115202000150)

----------------------------------------------------------------------------------
Πρόγραμμα "mvote" για εισαγωγή/εξαγωγή πληροφοριών και στατιστικών μιας ψηφοφορίας
        (υλοποιώντας τις δομες Linear Hash Table και Inverted Linked List)        
----------------------------------------------------------------------------------

COMPILATION/EXECUTION ΤΟΥ ΠΡΟΓΡΑΜΜΑΤΟΣ:

1) Separate compilation του προγράμματος, με χρήση Makefile, στο tty μέσω της εντολής:
…/sdi2000150-MoraitisTheodoros>make
, με την οποία δημιουργείται το εκτελέσιμο “mvote”.
2) Εκτέλεση του προγράμματος, στο tty μέσω της εντολής:
…/sdi2000150-MoraitisTheodoros>./mvote -f <registeredvoters> -b <bucketentries>
  2.1) Εκτέλεση του προγράμματος χρησιμοποιώντας valgrind, στο tty μέσω της εντολής:
  …/sdi2000150-MoraitisTheodoros>valgrind ./mvote -f <registeredvoters> -b <bucketentries>
  2.2) Αυτοματοποιημένη εκτέλεση ενός παραδείγματος του προγράμματος
  (με <registeredvoters> = voters50.csv, και <bucketentries> = 2), στο tty μέσω της εντολής:
  …/sdi2000150-MoraitisTheodoros>make run
  2.3) Αυτοματοποιημένη εκτέλεση ενός παραδείγματος του προγράμματος χρησιμοποιώντας valgrind
  (με <registeredvoters> = voters50.csv, και <bucketentries> = 2), στο tty μέσω της εντολής:
  …/sdi2000150-MoraitisTheodoros>make valgrind
3) Clean των αρχείων .ο καθώς και του εκτελέσιμου αρχείου που δημιουργήθηκαν μετά το compilation, 
στο tty μέσω της εντολής:
…/sdi2000150-MoraitisTheodoros>make clean

Σχόλια:

-Το <registeredvoters> είναι ένα αρχείο με κάθε γραμμή του να περιέχει τα στοιχεία ενός voter. 

-Το <bucketentries> είναι ένας ακέραιος που παρέχει τον μέγιστο αριθμό από κλειδιά που μπορεί να περιέχει το κάθε bucket.

-Τα 2 «σύνολα» των arguments “-f <registeredvoters>” και “-b <bucketentries>” μπορούν να δοθούν μεταξύ τους σε τυχαία σειρά.

-Οι τρόποι εκτέλεσης 2.2 και 2.3 αποτελούν απλά testing χρησιμοποιώντας το συγκεκριμένο αρχείο με όνομα voters50.csv που δόθηκε. 
Για να λειτουργήσουν θα πρέπει χειροκίνητα ο user να βάλει στο directory του προγράμματος το συγκεκριμένο αρχείο voters50.csv, 
για αυτό και δεν αποτελούν τον προβλεπόμενο τρόπο εκτέλεσης του προγράμματος.


SOURCE/HEADER FILES ΤΟΥ ΠΡΟΓΡΑΜΜΑΤΟΣ:

mvote.c: 
Παρέχει την συνάρτηση main, καθώς και δυο βοηθητικές συνάρτησης που χρησιμοποιούνται από την main. 
Είναι υπεύθυνο για την αρχικοποίηση του Linear Hash Table καθώς και για την εκτέλεση των εντολών της mvote. 
Για την εκτέλεση των εντολών της mvote παρέχεται ένα Prompt στον χρήστη, ο οποίος δίνει κάποια εντολή 
(μια από τις ακόλουθες: “l <pin>”, “i <pin> <lname> <fname> <zip>”, “m <pin>”, “bv <fileofkeys>”, “v”, “perc”, “z <zipcode>”, “o”, “print”, “exit”). 
Μετά την εκτέλεση κάποιας εντολής, το Prompt ξαναεμφανίζεται, επαναληπτικά, ζητώντας κάποια επόμενη εντολή, 
μέχρις ότου να δοθεί η εντολή “exit” όπου το πρόγραμμα τερματίζει. Με την, έξτρα, εντολή “print” αναπαράγονται, 
με τρόπο κατανοητικό και πλήρη, τα περιεχόμενα των δομών Linear Hash Table και Inverted Linked List την δεδομένη χρονική στιγμή.

functions.c: 
Παρέχει την υλοποίηση των συναρτήσεων που χρησιμοποιούνται για την εκτέλεση των εντολών της mvote. 
Έχει μια συνάρτηση (και κάποιες βοηθητικές) για κάθε μια εντολή της mvote, εκτός από την “i <pin> <lname> <fname> <zip>”, 
για την οποία χρησιμοποιείται η συνάρτηση lht_insertvoter, και την “bv <fileofkeys>”, για την οποία χρησιμοποιείται η συνάρτηση m_function.

functions.h: 
Παρέχει την δήλωση των συναρτήσεων του functions.c.

implementation.c: 
Παρέχει την υλοποίηση των συναρτήσεων του Linear Hash Table και της Inverted Linked List. 

-Για το Linear Hash Table παρέχει συναρτήσεις: για την δημιουργία του (lht_createtable), 
για την εισαγωγή εγγραφών σε αυτό (lht_insertvoter), για τον έλεγχο για splitting of bucket (lht_check_for_split), 
για την εκτύπωση των περιεχομένων του (lht_printtable), για την αποδέσμευση της μνήμης που δέσμευσε (lht_free). 
Για κάθε μια από αυτές τις συναρτήσεις, υπάρχει και από μια βοηθητική συνάρτηση (*_overflown) που βοηθάει στην υλοποίηση τους.

-Για την Inverted Linked List παρέχει συναρτήσεις: για την δημιουργία της (list_create), 
για την εισαγωγή entries σε αυτή (list_insert), για την εκτύπωση των περιεχομένων της (list_print), 
για την αποδέσμευση της μνήμης που δέσμευσε (list_free).  Υπάρχουν και κάποιες βοηθητικές συναρτήσεις που βοηθούν στην υλοποίηση των παραπάνω συναρτήσεων.

-Επίσης παρέχονται κάποιες γενικές/βοηθητικές συναρτήσεις που χρησιμοποιούνται από τις παραπάνω συναρτήσεις (του functions.c αλλά και του implementation.c).

interface.h:
Παρέχει την δήλωση των συναρτήσεων του implementation.c.

structs.h:
Παρέχει την δήλωση των δομών που χρησιμοποιούνται από το πρόγραμμα, 
για την υλοποίηση των Linear Hash Table και Inverted Linked List.

-Για το Linear Hash Table χρησιμοποιείται η δομή LinearHashTable. 
Ένα από τα πεδία της είναι ένας δυναμικός πίνακας που περιέχει τα buckets (δείκτες σε buckets). 
Το κάθε bucket είναι κι αυτό μια δομή (Bucket). Η δομή Bucket είναι αυτοαναφορική 
(περιέχει ένα πεδίο struct Bucket* overflown, που αντιπροσωπεύει το/τα ενδεχόμενο/α overflown page(s) αυτού του bucket). 
Επίσης, η δομή Bucket περιέχει έναν πίνακα με τα keys και έναν πίνακα με τους voters του (δείκτες σε voters). 
Αυτοί οι δυο πίνακες είναι “mapped” μεταξύ τους, 
δηλαδή πχ το πρώτο στοιχείο του πίνακα με τα keys περιέχει το key του voter που βρίσκεται στο πρώτο στοιχείo του πίνακα με τους voters, κ.ο.κ.. 
Ο κάθε voter είναι και αυτός μια δομή (Voter) που περιέχει τα στοιχεία ενός ψηφοφόρου (<PIN> <lname> <fname> <zipcode> <status>).

-Για την Inverted Linked List χρησιμοποιείται η δομή InvertedLinkedList. 
Αυτή περιέχει έναν δείκτη στον πρώτο κόμβο της λίστας (head), καθώς και μια ένδειξη για το αν η λίστα είναι άδεια (is_empty). 
Ο κάθε κόμβος της λίστας είναι μία δομή (Zipcode), η οποία είναι αυτοαναφορική 
(περιέχει ένα πεδίο struct Zipcode* next, που αντιπροσωπεύει το/τα ενδεχόμενο/α next zipcode node(s) της λίστας). 
Επίσης, η δομή Zipcode περιέχει και έναν δείκτη σε entry το οποίο είναι κι αυτό μια δομή (Entry) 
και περιέχει την πληροφορία ενός ψηφίσαντος ψηφοφόρου στο συγκεκριμένο zipcode. Η δομή Entry είναι αυτοαναφορική 
(περιέχει ένα πεδίο struct Entry* next_entry, που αντιπροσωπεύει το/τα ενδεχόμενο/α next entry/ies στο συγκεκριμένο zipcode). 
Η Inverted Linked List πρόκειται για μια 2-διαστατη Απλά Συνδεδεμένη Λίστα. 
Απλά συνδεδεμένη γιατί έχουμε πρόσβαση σε κάθε κόμβο (zipcode) της λίστας μόνο από την αρχή της, 
και 2-διαστατη γιατί από κάθε κόμβο (zipcode) ουσιαστικά ξεκινάει μια ακόμη απλά συνδεδεμένη λίστα με τα entries των ψηφίσαντων ψηφοφόρων στο συγκεκριμένο zipcode. 


ΠΑΡΑΔΟΧΕΣ ΤΟΥ ΠΡΟΓΡΑΜΜΑΤΟΣ:

-Το splitting ενός bucket συμβαίνει (οτ)αν το λ > 0.75.

-Χρησιμοποιείται μια εξωτερική (external) μεταβλητή “int previousones”, η οποία αρχικοποιείται με το αρχικό πλήθος των buckets, 
και κάθε φορά κρατάει το προηγούμενο πλήθος των buckets (του προηγούμενου round). 
Αυτή είναι χρήσιμη σχετικά με το αν/πότε γίνεται η αλλαγή round (χρησιμοποιείται στην συνάρτηση lht_check_for_split).

-Το status των voters σχετικά με το αν έχουν ψηφίσει ή όχι αντιπροσωπεύεται από μια boolean μεταβλητή status (στην δομή Voter), 
status == 1 σημαίνει “Υ” (έχει ψηφίσει), status == 0 σημαίνει “Ν” (δεν έχει ψηφίσει).

-Συγκεκριμένα για την εντολή “z <zipcode>” το expected output εκτυπώνεται με αντίστροφη σειρά από αυτήν που δίνεται στους κανόνες μορφοποίησης εξόδου 
(δηλαδή πρώτα εκτυπώνονται τα “<pin>” και μετά το “number voted in <zipcode>”).


ΠΟΛΥΠΛΟΚΟΤΗΤΑ ΔΟΜΩΝ ΤΟΥ ΠΡΟΓΡΑΜΜΑΤΟΣ:

-Η πολυπλοκότητα εισαγωγής εγγραφών αλλά και προσπέλασης του Linear Hash Table είναι Ο(1). 
Και αυτό γιατί πρόκειται για μια δομή που χρησιμοποιεί hashing, 
άρα κάθε φορά που μια εγγραφή πρέπει να εισαχθεί στην δομή είναι γνωστό σε αυτήν το που θα εισάγει την εγγραφή (σε ποιο bucket ή την επέκταση του), 
με βάση το κλειδί-pin της εγγραφής και την τρέχουσα οικογένεια hash functions. 
Κάποιες έξτρα λειτουργίες (προσπέλαση overflown pages, splitting of buckets, κλπ) είναι μηδαμινές μπροστά στο μέγεθος της δομής 
(στο πλήθος των εγγραφών που εισέρχονται) και δεν επηρεάζουν την πολυπλοκότητα, η οποία παραμένει, κατά μέσο όρο, Ο(1). 
Το ίδιο ισχύει και για την προσπέλαση του Linear Hash Table.

-Η πολυπλοκότητα χειρότερης περίπτωσης εισαγωγής εγγραφών στην Inverted Linked List είναι Ο(N*M), 
όπου Ν είναι το πλήθος των zipcodes της δομής, και Μ το πλήθος των ψηφίσαντων ψηφοφόρων σε αυτό το zipcode που γίνεται η εισαγωγή. 
Η χειρότερη αυτή περίπτωση συμβαίνει όταν το zipcode το οποίο ψάχνουμε για να γίνει η εισαγωγή, βρίσκεται στο τέλος της λίστας 
(εξου και το Ν στο Ο(Ν*Μ). Tο Μ παραμένει «δυναμικά σταθερό» και εξαρτάται από το πόσοι ψηφισαντες ψηφοφόροι υπάρχουν την δεδομένη στιγμή στο εκάστοτε zipcode). 
Στην πραγματικότητα αυτή η πολυπλοκότητα είναι πολύ μικρότερη, ειδικά για την προσπέλαση των εγγραφών της λίστας, 
αφού η λίστα υπάρχει για να προσπελαυνουμε «μαζικά» κάθε ομάδα ψηφισαντων ψηφοφόρων ενός zipcode. 
Άρα το Μ απαλείφεται, και μένει ως πολυπλοκότητα χειρότερης περίπτωσης η Ο(Ν). 
Αλλά ακόμα και αυτή κατά μέσο όρο είναι κοντά στο Ο(Ν/2).


ΕΛΛΕΙΨΕΙΣ ΤΟΥ ΠΡΟΓΡΑΜΜΑΤΟΣ:

-Κατά το splitting ενός bucket οι θέσεις των voters που «φεύγουν» από το τρέχον bucket και μεταφέρονται στο νέο παραμένουν κενές. 
Για παράδειγμα, ας υποθέσουμε ότι το 1ο bucket έχει ένα overflown page, και τα entries και των δυο (bucket+overflown_page) είναι γεμάτα. 
Αν αυτό, το 1ο bucket, γίνει split, και τύχει να μεταφερθούν μόνο τα entries του bucket (επειδή τυχαίνει μόνο αυτά να hashαρουν στο νέο bucket), 
τότε τα entries του overflown page θα παραμείνουν σε αυτό, χωρίς να γίνουν shift στο bucket (που τώρα είναι κενό). 
Το συγκεκριμένο θέμα δεν επηρεάζει κάπως την λειτουργία του προγράμματος και ούτε δημιουργεί προβλήματα κατά την εκτέλεση, 
αφού οι κενές αυτές θέσεις μπορεί να ξαναγεμίσουν με την ενδεχομένη εισαγωγή νέων εγγράφων σε αυτό το bucket. 
Απλώς, δημιουργεί το ζήτημα ότι παραμένουν κάποιες κενές θέσεις και κάποια (κενά ή μη) overflown pages παραμένουν allocated στην διάρκεια της εκτέλεσης του προγράμματος, 
χωρίς να χρειάζονται (όχι πολλά, μιας και το linear hashing «αναλαμβάνει» να «κρατάει» το πλήθος των overflown pages σε ελάχιστα).

-Συγκεκριμένα για την εντολή “bv <fileofkeys>” δεν έχει γίνει ο έλεγχος για το αν το εκάστοτε <pin> είναι ακέραιος 
(δηλαδή λείπει το error indication: “Malformed Input” if <pin> not an int).

-Συγκεκριμένα για την εντολή “exit” δεν υλοποιηθηκε η καταγραφη των bytes που εγιναν allocated/freed και, αρα, 
δεν εμφανιζεται το expected output “<num> of Bytes Released”.
