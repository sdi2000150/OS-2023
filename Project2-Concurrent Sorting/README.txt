OperatingSystems-Fall2023-Project2
**************README**************

Όνομα: Θεόδωρος Μωραΐτης
UserID: sdi2000150 (1115202000150)

----------------------------------------------------------------
Πρόγραμμα "mysort" για την ταξινόμηση αρχείου εγγραφών (Records)
      (χρησιμοποιώντας multiple processes, pipes & signals)     
----------------------------------------------------------------
_______________________________________________________________________________
COMPILATION/EXECUTION ΤΟΥ ΠΡΟΓΡΑΜΜΑΤΟΣ:

1) Separate compilation του προγράμματος, με χρήση Makefile, στο tty μέσω της εντολής:
…/sdi2000150-MoraitisTheodoros> make
, με την οποία δημιουργείται το εκτελέσιμο "mysort".

2) Εκτέλεση του προγράμματος, στο tty μέσω της εντολής:
…/sdi2000150-MoraitisTheodoros> ./mysort -i <DataFile> -k <NumofChildren> -e1 <sorting1> -e2 <sorting2>

 Για την αυτοματοποιημένη εκτέλεση κάποιων παραδειγμάτων του προγράμματος (για testing):
 2.1) Αυτοματοποιημένη εκτέλεση ενός παραδείγματος του προγράμματος
  (με <DataFile> = voters50000.bin, <NumofChildren> = 4, <sorting1> = mybubblesort, <sorting2> = myselectsort), 
  στο tty μέσω της εντολής:
  …/sdi2000150-MoraitisTheodoros> make run
 2.2) Αυτοματοποιημένη εκτέλεση ενός παραδείγματος του προγράμματος χρησιμοποιώντας time 
  (με <DataFile> = voters50000.bin, <NumofChildren> = 4, <sorting1> = mybubblesort, <sorting2> = myselectsort), 
  στο tty μέσω της εντολής:
  …/sdi2000150-MoraitisTheodoros> make time
 2.3) Αυτοματοποιημένη εκτέλεση ενός παραδείγματος του προγράμματος χρησιμοποιώντας valgrind
  (με <DataFile> = voters50000.bin, <NumofChildren> = 4, <sorting1> = mybubblesort, <sorting2> = myselectsort), 
  στο tty μέσω της εντολής:
  …/sdi2000150-MoraitisTheodoros> make valgrind
 2.4) Αυτοματοποιημένη εκτέλεση ενός παραδείγματος του προγράμματος χρησιμοποιώντας valgrind & trace & track children
  (με <DataFile> = voters50.bin, <NumofChildren> = 3, <sorting1> = mybubblesort, <sorting2> = myselectsort), 
  στο tty μέσω της εντολής:
  …/sdi2000150-MoraitisTheodoros> make trace

3) Clean των αρχείων .ο καθώς και των εκτελέσιμων που δημιουργήθηκαν μετά το compilation, 
στο tty μέσω της εντολής:
…/sdi2000150-MoraitisTheodoros> make clean

Σχόλια για την εκτέλεση του προγράμματος:

-Το <DataFile> είναι ένα αρχείο που περιέχει πολλαπλά Records σε binary μορφή, το <NumofChildren>
 είναι ένας ακέραιος βαση του οποίου καθορίζεται το πλήθος των διεργασιών-παιδιών που θα δημιουργηθούν, 
 το <sorting1> είναι ένα εκτελέσιμο πρόγραμμα για ταξινόμηση Records, το <sorting2> είναι ακόμη ένα
 εκτελέσιμο πρόγραμμα για ταξινόμηση Records

-Τα 4 "σύνολα" των arguments "-i <DataFile>", "-k <NumofChildren>", "-e1 <sorting1>", "-e2 <sorting2>"
 μπορούν να δοθούν μεταξύ τους σε τυχαία σειρά (με το εκάστοτε flag + argument να είναι μαζί και με αυτή την σειρά).

-Οι τρόποι εκτέλεσης 2.1, 2.2, 2.3, 2.4 αποτελούν απλά testing χρησιμοποιώντας το/τα συγκεκριμένο/α αρχείο/α που δόθηκε/αν. 
 Για να λειτουργήσουν θα πρέπει χειροκίνητα ο user να βάλει στο directory του προγράμματος το/τα συγκεκριμένο/α αρχείο/α, 
 για αυτό και δεν αποτελούν τον προβλεπόμενο τρόπο εκτέλεσης του προγράμματος.

_______________________________________________________________________________
SOURCE/HEADER FILES ΤΟΥ ΠΡΟΓΡΑΜΜΑΤΟΣ:

mysort.c:
>Βασική ιδέα:
Παρέχει την συνάρτηση main, η οποία, όταν ξεκινάει την εκτέλεσή της, αποτελεί και την βασική διεργασία, την ρίζα,
δηλαδή τον Coordinator στην ιεραρχία των διεργασιών. Δημιουργεί την ζητούμενη ιεραρχία των διεργασιών με βάση τον 
αριθμό k (<NumofChildren>) που δώθηκε ως παράμετρος κατα την εκτέλεση. Αρχικά δημιουργεί παιδιά-Splitter/Mergers πλήθους k,
καλώντας fork() k φορές. Το κάθε παιδί-Splitter/Merger δημιουργεί παιδιά-Sorters πλήθους k-i (δηλαδή το πλήθος παιδιών-Sorters
που δημιουργεί εξαρτάται απο το την θέση του στην ιεραρχία, ως ενδιάμεσος κόμβος), καλώντας fork() k-i φορές. Το κάθε παιδί-Sorter
καλεί την exec, εκτελώντας ένα από τα δυο προγράμματα ταξινόμησης που δώθηκαν ως παράμετροι κατά την εκτέλεση. Όταν το παιδί-Sorter
ταξινομήσει το "τεμάχιο" του αρχείου που του αναλογεί, στέλνει στον γονιό-Splitter/Merger τις ταξινομημένες εγγραφές μέσω pipe.
Ο γονιός-Splitter/Merger λαμβάνει τις ταξινομημένες εγγραφές που του έστειλαν όλα τα παιδιά-Sorters του μέσω pipes, 
τις συγχωνεύει σε ένα ενιαίο array ταξινομημένων εγγραφών, και στέλνει στον γονιό-Coordinator τις ταξινομημένες αυτές εγγραφές μέσω pipe.
Ο γονιός-Coordinator λαμβάνει τις ταξινομημένες εγγραφές που του έστειλαν όλα τα παιδιά-Splitters/Mergers του μέσω pipes, τις συγχωνεύει
σε ένα ενιαίο array ταξινομημένων εγγραφών, και τις εμφανίζει στο terminal. Επιπλέον, ο Coordinator εμφανίζει στο terminal και τους 
χρόνους του κάθε Sorter (τους οποίους έχει λάβει επίσης μέσω pipes), καθώς και το πλήθος των signals SIGUSR1 και SIGUSR2 που έλαβε από
τα παιδιά-Splitters/Mergers του και τα εγγόνια-Sorters του αντίστοιχα.

>Λεπτομέρειες:
-Ο κάθε Sorter ξέρει ποιό "τεμάχιο" του αρχείου θα ταξινομήσει, εφόσον λαμβάνει ως παραμέτρους, μέσω της exec, το αρχείο εγγραφών
αλλά και το starting και ending position μέσα σε αυτό (σε bytes), το οποίο του αναλογεί. Για να επιτευχθεί αυτό, ο Coordinator
δημιουργεί δυο, πολυδιάστατους, πίνακες (starting_pos & ending_pos, οι οποίοι είναι mapped μεταξύ τους), ο πρώτος γεμίζει με τα starting
positions ολων των Sorters, και ο δεύτερος με τα ending positions όλων των Sorters. Με κάποιες πράξεις, όπως καθορίζεται και από την 
εκφώνηση, μοιράζεται το αρχείο, και είναι προκαθοριζμένο το ποιό είναι το "τεμάχιο" του κάθε Sorter (Σημείωση: λόγω της μη-τέλειας διαίρεσης
με το k, ο τελευταίος Sorter, δηλαδή ο μοναδικός Sorter του τελευταίου Splitter/Merger, ειναι αυτός που "φορτώνεται" την περίσσια
δουλεία, δηλαδή κάποιες εξτρα εγγραφές).
-Οι διεργασίες-παιδιά (Splitters/Mergers ως παιδιά του Coordinator, και Sorters ως παιδιά των Splitters/Mergers) στέλνουν τις εκάστοτε
ταξινομημένες εγγραφές στον αντιστοίχο γονιό τους μέσω pipes. Για να επιτευχθεί αυτό, ο Coordinator δημιουργεί δυο, πολυδιάστατους, 
πίνακες (merger_pipe & sorter_pipe), ο πρώτος περιέχει τα pipes του κάθε Splitter/Merger με τον Coordinator, και ο δεύτερος περιέχει 
τα pipes του καθε Sorter με τον εκάστοτε Splitter/Merger του. Άρα υπάρχουν όσα pipes όσες και οι διεργασίες-παιδιά (δηλαδή οι ενδιάμεσοι 
κόμβοι και οι κόμβοι-φυλλα της ιεραρχίας).
-Ο Coordinator δημιουργεί και δυο, πολυδιάστατους, πίνακες (merged_records & records) που χρησιμοποιούνται για να αποθηκεύει, ο ίδιος, 
τις ταξινομημένες εγγραφές που λαμβάνει από τους Splitters/Mergers (στον merged_records), και για να αποθηκευει ο εκάστοτε Splitter/Merger 
τις ταξινομημένες εγγραφές που λαμβάνει από τους Sorters (στον records).
-Ο Coordinator δημιουργεί και έναν, πολυδιάστατο, πίνακα (times), ο οποίος χρησιμοποιείται για να αποθηκεύονται οι χρόνοι (που χρειάστηκε
κάθε Sorter), τους οποίους στέλνουν οι Sorters στον εκάστοτε Splitter/Merger και έπειτα οι Splitters/Mergers στον Coordinator (Σημείωση:
αυτούς τους χρόνους τους στέλνει ο κάθε Sorter στον γονιό-Splitter/Merger του μέσω του ίδιου pipe που έχουν για να στείλει τις ταξινομημένες
εγγραφές, και αντίστοιχα τους στέλνει ο κάθε Splitter/Merger στον γονιό-Coordinator του μέσω του ίδιου pipe που έχουν για να στείλει 
τις ταξινομημένες εγγραφές).
-Το write-end των pipes των Splitters/Mergers με τον Coordinator γινεται duplicated στον fd 3, ώστε να ξέρουν οι Splitters/Mergers 
ακριβώς που να γράψουν τις ταξινομημένες εγγραφές τους. Το write-end των pipes των Sorters με τον εκάστοτε Splitter/Merger γινεται 
duplicated στον fd 1, ώστε να ξέρουν οι Sorters ακριβώς που να γράψουν τις ταξινομημένες εγγραφές τους.
-Ο κάθε Splitter/Merger αφού λάβει όλα τα ταξινομημένα "τεμάχια" από τα παιδιά-Sorters του, τα κάνει merge σε ένα ενιαίο array με
ταξινομημένες εγγραφές, χρησιμοποιώντας την συνάρτηση MergeSort. Αντίστοιχα ο Coordinator αφού λάβει όλα τα ταξινομημένα "τεμάχια" 
από τα παιδιά-Splitters/Mergers του, τα κάνει merge σε ένα ενιαίο array με ταξινομημένες εγγραφές, χρησιμοποιώντας την ίδια συνάρτηση 
MergeSort.

mysort_functions.c: 
Παρέχει τον ορισμό: των δυο εξωτερικών μεταβλητών (USR1_counter και USR2_counter), των συναρτήσεων-handlers των SIGUSR1 και SIGUSR2,
της συνάρτησης MergeSort που χρησιμοποιείται για συγχώνευση ταξινομημένων πινάκων σε έναν ενιαίο ταξινομημένο πίνακα εγγραφών 
(προκειται για το merging part του κλασσικού αλγορίθμου Merge Sort), και της συνάρτησης free_function που χρησιμοποιείται για να 
γίνουν τα κατάλληλα free των memory allocations in heap πριν κάνει exit οποιαδήποτε διεργασία που έχει δημιουργηθεί μέσα στην main.

mysort_prototypes.h: 
Παρέχει την δήλωση των συναρτήσεων/εξωτερικών μεταβλητών του mysort_functions.c, καθώς και την δήλωση της δομής Record.


mybubblesort.c: 
Πρόκειται για ένα από τα δυο προγράμματα ταξινόμησης που χρησιμοποιεί η mysort. Κατά την κλήση της παίρνει σαν ορίσματα
το αρχειό εγγραφών (<DataFile>), το starting και ending position μέσα σε αυτό, τα οποία καθορίζουν ποιό μέρος του θα 
ταξινομήσει, καθώς και το pid του Coordinator (ώστε να μπορέσει να του στείλει το ζητούμενο SIGUSR2 signal).
Αρχικά ξεκινάει τους timers (όπως αυτοί δώθηκαν στην εκφώνηση) ώστε να χρονομετρήσει πόσο χρόνο της πήραν τα διάφορα
operations της. Έπειτα διαβάζει από το αρχείο, από το "τεμάχιο" που καθορίζουν τα starting και ending positions, και
αποθηκεύει τις εγγραφές σε ενα array. Καλώντας την συνάρτηση BubbleSort το array ταξινομείται. Στην συνέχεια γράφει
στον fd 1 (δηλαδή στο write-end του pipe με τον γονιό-Splitter/Merger) τις ταξινομημένες εγγραφές, μία-μία και με τη 
σειρά. Επίσης, αφού γράψει όλες τις εγγραφές, υπολογιζεί και τους timers, που είχε θέσει στην αρχή, και γράφει αυτούς
τους χρόνους στον ίδιο fd 1 (δηλαδή στο write-end του ίδιου pipe). Τέλος, στέλνει ένα SIGUSR2 signal στον Coordinator.

mybubblesort_function.c:
Παρέχει τον ορισμό της συνάρτησης BubbleSort που χρησιμοποιείται για την ταξινόμηση ενός πίνακα με εγγραφές (πρόκειται
για τον κλασσικό αλγόριθμο Bubble Sort).

mybubblesort_prototype.h:
Παρέχει την δήλωση της συνάρτησης του mybubblesort_function.c, καθώς και την δήλωση της δομής Record.


myselectsort.c:
Αντίστοιχα, δουλεύει ακριβώς όπως και η mybubblesort.c, μόνο που καλεί την συνάρτηση SelectSort για την ταξινόμηση των
εγγραφών.

myselectsort_function.c:
Παρέχει τον ορισμό της συνάρτησης SelectSort που χρησιμοποιείται για την ταξινόμηση ενός πίνακα με εγγραφές (πρόκειται
για τον κλασσικό αλγόριθμο Select Sort).

myselectsort_prototype.h:
Παρέχει την δήλωση της συνάρτησης του myselectsort_function.c, καθώς και την δήλωση της δομής Record.

_______________________________________________________________________________
ΣΧΕΔΙΑΣΤΙΚΕΣ ΕΠΙΛΟΓΕΣ ΤΟΥ ΠΡΟΓΡΑΜΜΑΤΟΣ:

-Τα pipes που χρησιμοποιήθηκαν ειναι regular (unnamed) pipes.

-Δεν έγινε χρήση των syscalls poll() ή select(). Λόγω των πολλαπλών pipes, την φύση του syscall read() (ως blocking),
και του σημείου στον κώδικα που γίνεται το read() από τα εκάστοτε pipes, επιτυγχάνεται ο ζητούμενος ταυτοχρονισμός
και οι διεργασίες, εκτελούμενες "ταυτοχρονα", οδηγούν στην ολοκλήρωση του προγράμματος πολύ γρήγορα, χωρίς την ανάγκη 
χρήσης των poll() ή select().

-Στις blocking system calls (read(), wait(), write()) έγινε ένας έλεγχος (if (errno == EINTR) repeat the syscall) 
σχετικά με την περίπτωση που διακοπούν ξαφνικά, λόγω κάποιου εισερχόμενου signal (SIGUSR1 ή SIGUSR2).

-Για πιο λεπτομερείς σχεδιαστικές επιλογές ο κώδικας είναι πλήρως εφοδιασμένος με σχόλια.

_______________________________________________________________________________
ΠΑΡΑΔΟΧΕΣ ΤΟΥ ΠΡΟΓΡΑΜΜΑΤΟΣ:

-Τα δυο προγράμματα ταξινόμησης, sorting1 και sorting2 που δίνονται σαν arguments κατά την εκτέλεση, εκτελούνται 
εναλλάξ από τα παιδιά-Sorters του καθε Splitter/Merger. Δηλαδή ο 1ος Sorter ενός Splitter/Merger εκτελεί το sorting1 
program, ο 2ος το sorting2 program, ο 3ος το sorting1 program, κ.ο.κ.

-Η φύση των signals που χρησιμοποιήθηκαν, και το handling αυτών, ως unreliable (non-queued) signals δημιουργούν το θέμα ότι
κάποια από αυτά ενδεχομένως να χάνονται κατά την εκτέλεση του προγράμματος, και γι' αυτό και τα πλήθη των SIGUSR1 και SIGUSR2
ενδεχομένως να ειναι λιγότερα από τα αναμενόμενα και να διαφέρουν από εκτέλεση σε εκτέλεση του προγράμματος.

_______________________________________________________________________________
ΠΟΛΥΠΛΟΚΟΤΗΤΑ ΣΥΝΑΡΤΗΣΕΩΝ ΤΑΞΙΝΟΜΗΣΗΣ ΚΑΙ ΣΥΓΧΩΝΕΥΣΗΣ ΤΟΥ ΠΡΟΓΡΑΜΜΑΤΟΣ:

-Η συνάρτηση BubbleSort του προγράμματος mybubblesort, έχει πολυπλοκότητα O(n^2),
όπου n το πλήθος των εγγραφών.

-Η συνάρτηση SelectSort του προγράμματος myselectsort, έχει πολυπλοκότητα O(n^2),
όπου n το πλήθος των εγγραφών.

-Η συνάρτηση MergeSort του προγράμματος mysort, έχει πολυπλοκότητα O(n*m), 
όπου n το πλήθος των τελικών συγχωνευμένων εγγραφών, και m το πλήθος των επιμέρους ταξινομημένων πινάκων.

_______________________________________________________________________________
ΕΛΛΕΙΨΕΙΣ ΤΟΥ ΠΡΟΓΡΑΜΜΑΤΟΣ:

-Δημιουργείται ένα πρόβλημα στην εκτέλεση όταν δίνεται μεγάλος αριθμός <NumofChildren> σε σχέση με το πλήθος των εγγραφών του αρχείου.
Για παράδειγμα για το αρχείο voters50.bin, για <NumofChildren> >= 8, αρχίζουν και εμφανίζονται λιγότερες ταξινομημένες εγγραφές από 50.
Δηλαδή σαν κάποιες εγγραφές να "χάνονται" (το πρόβλημα κατά πάσα πιθανότητα προέρχεται από τον τροπό που χωρίζεται το αρχείο σε "τεμάχια",
και ,πχ , για <NumofChildren> = 8, εν τέλει δημιουργούνται 36 Sorters, άρα το slice του καθενός για αρχείο 50 εγγραφών είναι πολύ μικρο,
και κάποιες operational αριθμητικες πράξεις που χρησιμοποιούνται γινονται τόσο μικρές που ουσιαστικά μηδενίζονται). Άρα για πλήθος Sorters
που συγκλίνει στο πλήθος των εγγραφών που θέλουμε να ταξινομήσουμε, δημιουργειταί το παραπάνω πρόβλημα.

-Ενώ έγινε ο έλεγχος στις blocking system calls (read(), wait(), write()), σχετικά με το errno == EINTR,
δεν έγινε κάποιος έλεγχος σχετικά με το ενδεχόμενο κάποιο syscall να έχει ήδη ξεκινήσει, πχ το διάβασμα η read(), 
και να διακοπεί στην μέση, μη εχόντας διαβάσει τα υπόλοιπα bytes (το συγκεκριμένο ενώ παρατήρησα ότι ίσως να χρειάζεται ελεγχο, 
δεν παρατήρησα σε κάποια εκτέλεση να δημιουργείται κάποιο θέμα - άρα ίσως και να μην δημιουργείται τελικά πρόβλημα).
